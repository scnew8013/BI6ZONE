<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Haven - Multiplayer RPG</title>
    <style>
        /* Gaming Theme Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, hsl(220, 13%, 8%), hsl(220, 13%, 12%));
            color: hsl(120, 100%, 85%);
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            position: relative;
        }

        .game-canvas {
            border: 2px solid hsl(120, 100%, 30%);
            border-radius: 8px;
            box-shadow: 0 0 20px hsl(120, 100%, 50%, 0.5);
            cursor: crosshair;
        }

        .game-ui {
            position: fixed;
            background: hsl(220, 13%, 10%);
            border: 1px solid hsl(120, 100%, 30%);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 0 20px hsl(120, 100%, 50%, 0.5);
        }

        .player-stats {
            top: 16px;
            left: 16px;
            min-width: 280px;
        }

        .minimap-panel {
            top: 16px;
            right: 16px;
            max-width: 200px;
            text-align: center;
        }

        .chat-panel {
            bottom: 16px;
            left: 16px;
            width: 280px;
            height: 160px;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .chat-panel.expanded {
            height: 350px;
            width: 400px;
        }

        .controls-panel {
            bottom: 16px;
            right: 16px;
            max-width: 300px;
        }

        .neon-text {
            color: hsl(120, 100%, 50%);
            text-shadow: 0 0 10px hsl(120, 100%, 50%, 0.8);
        }

        .health-bar, .mana-bar {
            height: 12px;
            border-radius: 6px;
            transition: width 0.3s ease;
        }

        .health-bar {
            background: hsl(0, 100%, 60%);
            box-shadow: 0 0 10px hsl(0, 100%, 60%, 0.7);
        }

        .mana-bar {
            background: hsl(240, 100%, 60%);
            box-shadow: 0 0 10px hsl(240, 100%, 60%, 0.7);
        }

        .bar-background {
            background: hsl(220, 13%, 15%);
            border-radius: 6px;
            overflow: hidden;
        }

        input, button {
            background: hsl(220, 13%, 15%);
            border: 1px solid hsl(120, 100%, 30%);
            color: hsl(120, 100%, 85%);
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        button {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: hsl(120, 100%, 20%);
            box-shadow: 0 0 10px hsl(120, 100%, 50%, 0.3);
        }

        .character-select {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: hsl(220, 13%, 10%);
            border: 2px solid hsl(120, 100%, 30%);
            border-radius: 12px;
            padding: 32px;
            box-shadow: 0 0 30px hsl(120, 100%, 50%, 0.5);
            text-align: center;
            min-width: 400px;
        }

        .class-selection {
            display: flex;
            gap: 16px;
            margin: 20px 0;
            justify-content: center;
        }

        .class-button {
            padding: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .class-button:hover, .class-button.selected {
            background: hsl(120, 100%, 20%);
            box-shadow: 0 0 15px hsl(120, 100%, 50%, 0.5);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            background: hsl(220, 13%, 8%);
            border-radius: 4px;
            margin-bottom: 8px;
            max-height: 80px;
        }

        .chat-panel.expanded .chat-messages {
            max-height: 250px;
        }

        .circular-minimap {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 2px solid hsl(120, 100%, 30%);
            background: hsl(220, 13%, 8%);
            position: relative;
            margin: 0 auto 12px auto;
            box-shadow: 0 0 20px hsl(120, 100%, 50%, 0.3);
        }

        .minimap-player {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .minimap-terrain {
            position: absolute;
            border-radius: 1px;
        }

        .chat-expand-btn, .close-controls-btn {
            background: none;
            border: none;
            color: hsl(120, 100%, 50%);
            font-size: 14px;
            cursor: pointer;
            margin-left: auto;
            padding: 0;
        }

        .chat-expand-btn:hover, .close-controls-btn:hover {
            color: hsl(120, 100%, 70%);
        }

        .xp-bar {
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
            background: hsl(280, 100%, 60%);
            box-shadow: 0 0 10px hsl(280, 100%, 60%, 0.7);
        }

        .message {
            font-size: 12px;
            margin-bottom: 4px;
        }

        .message .username {
            color: hsl(120, 100%, 50%);
            font-weight: bold;
        }

        .chat-input-container {
            display: flex;
            gap: 8px;
        }

        .chat-input {
            flex: 1;
        }

        .player-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
        }

        .current-player {
            background: hsl(120, 100%, 20%, 0.3);
            border: 1px solid hsl(120, 100%, 30%);
        }

        .other-player {
            background: hsl(220, 13%, 8%, 0.5);
        }

        .player-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .current-player .player-dot {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .hidden {
            display: none;
        }

        .interaction-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: hsl(220, 13%, 10%);
            border: 2px solid hsl(120, 100%, 30%);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 0 30px hsl(120, 100%, 50%, 0.5);
            min-width: 400px;
            max-width: 500px;
            z-index: 1000;
        }

        .shop-items {
            max-height: 300px;
            overflow-y: auto;
            margin: 16px 0;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            margin-bottom: 8px;
            background: hsl(220, 13%, 8%);
            border-radius: 4px;
            border: 1px solid hsl(120, 100%, 20%);
        }

        .shop-item:hover {
            background: hsl(120, 100%, 15%);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        .controls-text {
            font-size: 12px;
            color: hsl(120, 20%, 65%);
            line-height: 1.4;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .gold-amount {
            color: hsl(60, 100%, 50%);
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" class="game-canvas" width="1200" height="800"></canvas>
    </div>

    <!-- Character Selection -->
    <div id="characterSelect" class="character-select">
        <h1 class="neon-text" style="margin-bottom: 24px;">Welcome to Pixel Haven</h1>
        <p style="margin-bottom: 20px;">Enter your name and choose your class:</p>
        
        <input type="text" id="playerName" placeholder="Enter your name..." style="width: 100%; margin-bottom: 20px;">
        
        <div class="class-selection">
            <div class="class-button" data-class="warrior">
                <div style="font-size: 24px;">‚öî</div>
                <div>Warrior</div>
                <div style="font-size: 10px;">High HP, Low MP</div>
            </div>
            <div class="class-button" data-class="mage">
                <div style="font-size: 24px;">‚ú¶</div>
                <div>Mage</div>
                <div style="font-size: 10px;">Low HP, High MP</div>
            </div>
            <div class="class-button" data-class="archer">
                <div style="font-size: 24px;">‚ûµ</div>
                <div>Archer</div>
                <div style="font-size: 10px;">Balanced Stats</div>
            </div>
        </div>
        
        <button id="startGame" style="width: 100%; margin-top: 20px;">Start Adventure</button>
    </div>

    <!-- Player Stats Panel -->
    <div id="playerStats" class="game-ui player-stats hidden">
        <div style="text-align: center; margin-bottom: 16px;">
            <h3 class="neon-text" id="playerNameDisplay"></h3>
            <p style="font-size: 12px; color: hsl(120, 20%, 65%);" id="playerClassDisplay"></p>
        </div>
        
        <div>
            <div class="stat-row">
                <span>HP</span>
                <span id="healthDisplay"></span>
            </div>
            <div class="bar-background" style="margin-bottom: 12px;">
                <div id="healthBar" class="health-bar" style="width: 100%;"></div>
            </div>

            <div class="stat-row">
                <span>MP</span>
                <span id="manaDisplay"></span>
            </div>
            <div class="bar-background" style="margin-bottom: 12px;">
                <div id="manaBar" class="mana-bar" style="width: 100%;"></div>
            </div>

            <div class="stat-row">
                <span>XP</span>
                <span id="xpDisplay">0/100</span>
            </div>
            <div class="bar-background" style="margin-bottom: 12px;">
                <div id="xpBar" class="xp-bar" style="width: 0%;"></div>
            </div>

            <div class="stat-row">
                <span>Gold:</span>
                <span id="goldDisplay" class="gold-amount"></span>
            </div>
        </div>
    </div>

    <!-- Minimap Panel -->
    <div id="minimapPanel" class="game-ui minimap-panel hidden">
        <div id="minimap" class="circular-minimap"></div>
        <p class="neon-text" style="font-size: 12px;">Online Players (<span id="playerCount">0</span>)</p>
    </div>

    <!-- Chat Panel -->
    <div id="chatPanel" class="game-ui chat-panel hidden">
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <h3 class="neon-text" style="margin: 0;">Chat</h3>
            <button id="chatExpandBtn" class="chat-expand-btn">‚á±</button>
        </div>
        <div id="chatMessages" class="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="chatInput" class="chat-input" placeholder="Type a message...">
            <button id="sendButton">Send</button>
        </div>
    </div>

    <!-- Controls Panel -->
    <div id="controlsPanel" class="game-ui controls-panel hidden">
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <h3 class="neon-text" style="margin: 0;">Controls</h3>
            <button id="closeControlsBtn" class="close-controls-btn">‚úï</button>
        </div>
        <div class="controls-text">
            <div>üéÆ <strong>WASD</strong> or <strong>Arrow Keys</strong> - Move</div>
            <div>‚ö° <strong>E</strong> or <strong>Space</strong> - Interact with NPCs</div>
            <div>üí¨ <strong>Enter</strong> - Send chat message</div>
            <div>üåü Walk near NPCs to interact with them</div>
        </div>
    </div>

    <!-- Interaction Dialog -->
    <div id="interactionOverlay" class="overlay hidden"></div>
    <div id="interactionDialog" class="interaction-dialog hidden">
        <h3 class="neon-text" id="npcName"></h3>
        <p id="npcDialogue" style="margin: 16px 0;"></p>
        <div id="shopItems" class="shop-items hidden"></div>
        <div style="text-align: right; margin-top: 16px;">
            <button id="closeDialog">Close</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Supabase Configuration
        const SUPABASE_URL = "https://yxtihsvpirmpmrffdbnt.supabase.co";
        const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4dGloc3ZwaXJtcG1yZmZkYm50Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MzUwMjAsImV4cCI6MjA3MDExMTAyMH0.0edpLL1XlfmyTEYfqyGnaUt0kMBcwwnjt0XlORrHRwQ";
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Game Constants
        const TILE_SIZE = 32;
        const MOVE_SPEED = 120;
        const UPDATE_INTERVAL = 50;
        const WORLD_WIDTH = 2000;  // MASSIVE OPEN WORLD - 20x bigger than before
        const WORLD_HEIGHT = 1500;  // GIGANTIC MAP for endless exploration

        // Game State
        let gameState = {
            players: {},
            messages: [],
            currentPlayer: null,
            isConnected: false,
            keys: {},
            animationFrame: 0,
            lastUpdate: Date.now(),
            interactionTarget: null
        };

        // World Data
        const TILES = {
            grass: { id: 'grass', type: 'grass', walkable: true, color: '#10b981' },
            stone: { id: 'stone', type: 'stone', walkable: true, color: '#64748b' },
            water: { id: 'water', type: 'water', walkable: false, color: '#3b82f6' },
            dirt: { id: 'dirt', type: 'dirt', walkable: true, color: '#a3540f' },
            wood: { id: 'wood', type: 'wood', walkable: false, color: '#92400e' },
            roof: { id: 'roof', type: 'roof', walkable: false, color: '#7c2d12' },
            door: { id: 'door', type: 'door', walkable: true, color: '#fbbf24' },
            wall: { id: 'wall', type: 'wall', walkable: false, color: '#525252' },
            floor: { id: 'floor', type: 'floor', walkable: true, color: '#d6d3d1' }
        };

        const BUILDINGS = [
            // MAIN TOWN (CENTER) - Starting Area
            { id: 'central-weapon-shop', name: 'Iron & Steel Armory', type: 'shop', x: 990, y: 735, width: 8, height: 8, entrance: { x: 994, y: 743 }, icon: '‚öîÔ∏è', description: 'Finest weapons and armor' },
            { id: 'central-potion-shop', name: 'Mystic Potions', type: 'shop', x: 1002, y: 735, width: 8, height: 8, entrance: { x: 1006, y: 743 }, icon: 'üß™', description: 'Magical potions and remedies' },
            { id: 'central-bank', name: 'Royal Bank', type: 'bank', x: 988, y: 750, width: 10, height: 6, entrance: { x: 993, y: 756 }, icon: 'üè¶', description: 'Store your valuables safely' },
            { id: 'central-inn', name: 'Golden Griffin Inn', type: 'inn', x: 1004, y: 750, width: 10, height: 6, entrance: { x: 1009, y: 756 }, icon: 'üè®', description: 'Rest and set respawn point' },
            { id: 'central-arena', name: 'Combat Arena', type: 'arena', x: 995, y: 760, width: 20, height: 8, entrance: { x: 1005, y: 768 }, icon: 'üèüÔ∏è', description: 'Test your skills in combat' },
            
            // NORTHERN TOWN - Frostpeak
            { id: 'north-blacksmith', name: 'Frostforge Smithy', type: 'blacksmith', x: 950, y: 150, width: 12, height: 10, entrance: { x: 956, y: 160 }, icon: 'üî®', description: 'Master crafters of the north' },
            { id: 'north-auction', name: 'Northern Auction House', type: 'auction', x: 970, y: 150, width: 15, height: 12, entrance: { x: 977, y: 162 }, icon: 'üè™', description: 'Player trading hub' },
            { id: 'north-bank', name: 'Frozen Vault', type: 'bank', x: 990, y: 150, width: 8, height: 8, entrance: { x: 994, y: 158 }, icon: 'üè¶', description: 'Secure storage' },
            { id: 'north-inn', name: 'Icewind Tavern', type: 'inn', x: 1000, y: 150, width: 12, height: 8, entrance: { x: 1006, y: 158 }, icon: 'üè®', description: 'Warm beds in the cold north' },
            { id: 'north-portal', name: 'Frostpeak Portal', type: 'portal', x: 1020, y: 150, width: 6, height: 6, entrance: { x: 1023, y: 156 }, icon: 'üåÄ', description: 'Fast travel nexus' },
            
            // SOUTHERN TOWN - Sunhaven
            { id: 'south-market', name: 'Sunhaven Market', type: 'shop', x: 1100, y: 1350, width: 20, height: 15, entrance: { x: 1110, y: 1365 }, icon: 'üè¨', description: 'Largest marketplace in the south' },
            { id: 'south-stable', name: 'Desert Wind Stables', type: 'stable', x: 1130, y: 1350, width: 15, height: 10, entrance: { x: 1137, y: 1360 }, icon: 'üêé', description: 'Finest mounts in the realm' },
            { id: 'south-guild', name: 'Sunhaven Guild Hall', type: 'guild', x: 1080, y: 1350, width: 18, height: 12, entrance: { x: 1089, y: 1362 }, icon: '‚öîÔ∏è', description: 'Adventurer headquarters' },
            
            // EASTERN TOWN - Moonport
            { id: 'east-dock', name: 'Moonport Docks', type: 'dock', x: 1750, y: 700, width: 25, height: 15, entrance: { x: 1762, y: 715 }, icon: '‚öì', description: 'Maritime trading post' },
            { id: 'east-auction', name: 'Eastern Auction Hall', type: 'auction', x: 1720, y: 720, width: 12, height: 10, entrance: { x: 1726, y: 730 }, icon: 'üè™', description: 'Rare item auctions' },
            { id: 'east-temple', name: 'Temple of the Moon', type: 'temple', x: 1730, y: 740, width: 14, height: 16, entrance: { x: 1737, y: 756 }, icon: '‚õ™', description: 'Sacred healing grounds' },
            
            // WESTERN TOWN - Ironhold
            { id: 'west-foundry', name: 'Great Foundry', type: 'foundry', x: 200, y: 650, width: 20, height: 18, entrance: { x: 210, y: 668 }, icon: 'üè≠', description: 'Industrial crafting hub' },
            { id: 'west-armory', name: 'Ironhold Armory', type: 'armory', x: 230, y: 650, width: 15, height: 12, entrance: { x: 237, y: 662 }, icon: 'üõ°Ô∏è', description: 'Military equipment supplier' },
            { id: 'west-bank', name: 'Dwarven Vault', type: 'bank', x: 180, y: 670, width: 10, height: 8, entrance: { x: 185, y: 678 }, icon: 'üè¶', description: 'Dwarven-secured storage' },
            
            // SCATTERED OUTPOSTS
            { id: 'outpost1-shop', name: 'Frontier Trading Post', type: 'shop', x: 300, y: 300, width: 8, height: 6, entrance: { x: 304, y: 306 }, icon: 'üè™', description: 'Remote trading outpost' },
            { id: 'outpost2-inn', name: 'Wayfarer\'s Rest', type: 'inn', x: 1600, y: 400, width: 10, height: 8, entrance: { x: 1605, y: 408 }, icon: 'üè®', description: 'Remote inn for travelers' },
            { id: 'outpost3-stable', name: 'Wild Horse Corral', type: 'stable', x: 500, y: 1200, width: 12, height: 10, entrance: { x: 506, y: 1210 }, icon: 'üêé', description: 'Wild mount taming' },
            { id: 'outpost4-tower', name: 'Mage\'s Tower', type: 'tower', x: 1400, y: 200, width: 8, height: 12, entrance: { x: 1404, y: 212 }, icon: 'üóº', description: 'Arcane research facility' },
            { id: 'outpost5-dungeon', name: 'Ancient Crypt Entrance', type: 'dungeon', x: 100, y: 1100, width: 10, height: 8, entrance: { x: 105, y: 1108 }, icon: 'üèõÔ∏è', description: 'Dungeon entrance' }
        ];

        const NPCS = [
            // === CENTRAL TOWN NPCs ===
            // Shopkeepers & Merchants
            { id: 'central-blacksmith', name: 'Gareth the Blacksmith', type: 'blacksmith', x: 994, y: 739, sprite: 'üî®', color: '#dc2626', 
              dialogue: ["Welcome to my forge!", "I craft the finest weapons in the land.", "What can I make for you today?"],
              shop: [
                { id: 'iron-sword', name: 'Iron Sword', type: 'weapon', price: 100, description: 'A sturdy iron blade', icon: '‚öîÔ∏è' },
                { id: 'steel-armor', name: 'Steel Armor', type: 'armor', price: 200, description: 'Protective steel plating', icon: 'üõ°Ô∏è' },
                { id: 'iron-helmet', name: 'Iron Helmet', type: 'armor', price: 75, description: 'Basic head protection', icon: '‚õëÔ∏è' }
              ]
            },
            { id: 'central-alchemist', name: 'Luna the Alchemist', type: 'shopkeeper', x: 1006, y: 739, sprite: 'üßô‚Äç‚ôÄÔ∏è', color: '#7c3aed',
              dialogue: ["Greetings, traveler!", "My potions will aid you on your journey.", "Each brew is made with ancient recipes."],
              shop: [
                { id: 'health-potion', name: 'Health Potion', type: 'potion', price: 25, description: 'Restores 50 HP', icon: '‚ù§Ô∏è' },
                { id: 'mana-potion', name: 'Mana Potion', type: 'potion', price: 30, description: 'Restores 50 MP', icon: 'üíô' },
                { id: 'strength-potion', name: 'Strength Elixir', type: 'potion', price: 50, description: 'Temporarily increases attack', icon: 'üí™' }
              ]
            },
            { id: 'central-banker', name: 'Banker Goldtooth', type: 'banker', x: 993, y: 753, sprite: 'üè¶', color: '#f59e0b',
              dialogue: ["Welcome to the Royal Bank!", "Your valuables are safe with us.", "How may I assist you today?"]
            },
            { id: 'central-innkeeper', name: 'Miriam the Innkeeper', type: 'innkeeper', x: 1009, y: 753, sprite: 'üè®', color: '#ec4899',
              dialogue: ["Welcome to the Golden Griffin!", "Rest here and set your respawn point.", "We have the finest beds in the realm!"]
            },
            { id: 'central-arena-master', name: 'Commander Rex', type: 'trainer', x: 1005, y: 764, sprite: 'üõ°Ô∏è', color: '#f59e0b',
              dialogue: ["Welcome to the Arena, warrior!", "Prove your worth in combat!", "Only the strongest survive here."]
            },

            // Quest Givers & Trainers
            { id: 'central-quest-giver1', name: 'Elder Thorne', type: 'quest-giver', x: 985, y: 745, sprite: 'üìú', color: '#6366f1',
              dialogue: ["I have urgent tasks for brave adventurers!", "The realm needs heroes like you.", "Accept my quests and earn great rewards!"]
            },
            { id: 'central-quest-board', name: 'Quest Board', type: 'quest-board', x: 990, y: 745, sprite: 'üìã', color: '#8b5cf6',
              dialogue: ["Check the board for available quests!", "New bounties posted daily!", "Choose your adventure!"]
            },
            { id: 'central-trainer', name: 'Master Aldric', type: 'trainer', x: 1015, y: 745, sprite: '‚ö°', color: '#10b981',
              dialogue: ["I can teach you new skills!", "Train with me to become stronger.", "Mastery requires dedication!"]
            },

            // Repair & Services
            { id: 'central-repair', name: 'Grimbold the Fixer', type: 'repair', x: 1000, y: 740, sprite: 'üîß', color: '#6b7280',
              dialogue: ["Bring me your broken gear!", "I can fix anything made of metal.", "Quality repairs at fair prices!"]
            },
            { id: 'central-mailbox', name: 'Postmaster Pine', type: 'mailbox', x: 1010, y: 740, sprite: 'üì¨', color: '#3b82f6',
              dialogue: ["I handle all mail and deliveries!", "Check for messages from friends.", "Sending letters across the realm!"]
            },

            // === NORTHERN TOWN (Frostpeak) NPCs ===
            { id: 'north-blacksmith', name: 'Bjorn Ironforge', type: 'blacksmith', x: 956, y: 155, sprite: 'üî®', color: '#1e40af',
              dialogue: ["The cold makes the steel stronger!", "Northern weapons are unmatched!", "Feel the bite of frost-forged steel!"],
              shop: [
                { id: 'frost-blade', name: 'Frost Blade', type: 'weapon', price: 250, description: 'Ice-cold steel that never dulls', icon: '‚ùÑÔ∏è‚öîÔ∏è' },
                { id: 'winter-armor', name: 'Winter Guard Armor', type: 'armor', price: 350, description: 'Protects against cold and steel', icon: 'üõ°Ô∏è‚ùÑÔ∏è' }
              ]
            },
            { id: 'north-auctioneer', name: 'Auctioneer Frost', type: 'auction', x: 977, y: 157, sprite: 'üè™', color: '#7c3aed',
              dialogue: ["Welcome to the finest auction house!", "Rare items from across the world!", "Place your bids wisely!"]
            },
            { id: 'north-banker', name: 'Vault-Keep Igrid', type: 'banker', x: 994, y: 154, sprite: 'üè¶', color: '#1e40af',
              dialogue: ["Your treasures stay frozen in time here!", "The vault never thaws, never fails.", "Perfect preservation guaranteed!"]
            },
            { id: 'north-innkeeper', name: 'Helga Warmhearth', type: 'innkeeper', x: 1006, y: 154, sprite: 'üè®', color: '#dc2626',
              dialogue: ["Come warm yourself by our fire!", "Hot meals and warm beds await!", "The cold cannot reach you here!"]
            },
            { id: 'north-portal-keeper', name: 'Portal-Mage Crystus', type: 'portal', x: 1023, y: 153, sprite: 'üåÄ', color: '#8b5cf6',
              dialogue: ["The portals connect all realms!", "Travel instantly across the world!", "Magic makes distance meaningless!"]
            },
            { id: 'north-stable-master', name: 'Fenrir the Beast-Tamer', type: 'stable', x: 965, y: 165, sprite: 'üê∫', color: '#374151',
              dialogue: ["Northern wolves make the best mounts!", "Fierce, loyal, and fast as the wind!", "Choose your companion wisely!"]
            },
            { id: 'north-quest-giver', name: 'Jarl Iceheart', type: 'quest-giver', x: 980, y: 165, sprite: 'üëë', color: '#1e40af',
              dialogue: ["The north faces many dangers!", "Prove yourself worthy of northern steel!", "Glory awaits the brave!"]
            },

            // === SOUTHERN TOWN (Sunhaven) NPCs ===
            { id: 'south-merchant', name: 'Merchant Prince Zahir', type: 'shopkeeper', x: 1110, y: 1360, sprite: 'üë≥‚Äç‚ôÇÔ∏è', color: '#f59e0b',
              dialogue: ["Welcome to the greatest market!", "Exotic goods from distant lands!", "Everything has a price, friend!"],
              shop: [
                { id: 'desert-blade', name: 'Scimitar of the Sands', type: 'weapon', price: 200, description: 'Curved blade of desert steel', icon: 'üèúÔ∏è‚öîÔ∏è' },
                { id: 'silk-robes', name: 'Silk Robes', type: 'armor', price: 150, description: 'Light but surprisingly protective', icon: 'üëò' },
                { id: 'spice-potion', name: 'Spiced Healing Draught', type: 'potion', price: 40, description: 'Exotic healing with a kick', icon: 'üå∂Ô∏è‚ù§Ô∏è' }
              ]
            },
            { id: 'south-stable-master', name: 'Malik the Horse-Whisperer', type: 'stable', x: 1137, y: 1355, sprite: 'üêé', color: '#92400e',
              dialogue: ["The finest steeds in all the land!", "Desert horses fear no terrain!", "They run like the wind itself!"]
            },
            { id: 'south-guild-master', name: 'Guild-Master Fatima', type: 'guild', x: 1089, y: 1357, sprite: '‚öîÔ∏è', color: '#dc2626',
              dialogue: ["Join our guild for great adventures!", "Together we are stronger!", "The guild always supports its members!"]
            },
            { id: 'south-quest-giver', name: 'Desert Oracle Amara', type: 'quest-giver', x: 1095, y: 1365, sprite: 'üîÆ', color: '#7c3aed',
              dialogue: ["The sands whisper of great deeds!", "Your destiny awaits in the desert!", "Accept the challenges of the waste!"]
            },
            { id: 'south-repair', name: 'Tinker Brass-Hands', type: 'repair', x: 1120, y: 1365, sprite: 'üîß', color: '#f59e0b',
              dialogue: ["Desert sand ruins everything!", "But I can fix anything!", "No gear too damaged for these hands!"]
            },
            { id: 'south-faction-vendor', name: 'Faction Agent Xeris', type: 'faction', x: 1105, y: 1370, sprite: 'üè¥', color: '#6366f1',
              dialogue: ["Serve the Desert Coalition!", "Earn reputation, earn rewards!", "Loyalty has its benefits!"]
            },

            // === EASTERN TOWN (Moonport) NPCs ===
            { id: 'east-dock-master', name: 'Captain Saltheart', type: 'shopkeeper', x: 1762, y: 710, sprite: '‚öì', color: '#3b82f6',
              dialogue: ["Welcome to Moonport!", "Finest goods from overseas!", "The sea provides all treasures!"],
              shop: [
                { id: 'pearl-sword', name: 'Pearl-Hilted Blade', type: 'weapon', price: 300, description: 'Elegant weapon from the deep', icon: 'ü¶™‚öîÔ∏è' },
                { id: 'sea-armor', name: 'Tide-Walker Armor', type: 'armor', price: 280, description: 'Never rusts, never fails', icon: 'üåäüõ°Ô∏è' },
                { id: 'sea-potion', name: 'Brine of Healing', type: 'potion', price: 35, description: 'Healing power of the sea', icon: 'üåä‚ù§Ô∏è' }
              ]
            },
            { id: 'east-auctioneer', name: 'Trade-Master Coral', type: 'auction', x: 1726, y: 725, sprite: 'üè™', color: '#ec4899',
              dialogue: ["Rare treasures from the deep!", "Auction house of the seas!", "Bid on legendary maritime finds!"]
            },
            { id: 'east-priest', name: 'Moon-Priest Celestine', type: 'trainer', x: 1737, y: 748, sprite: '‚õ™', color: '#f3f4f6',
              dialogue: ["The moon guides all travelers!", "Seek blessing for your journey!", "Healing light shines here!"]
            },
            { id: 'east-quest-giver', name: 'Harbor-Master Triton', type: 'quest-giver', x: 1750, y: 715, sprite: 'üî±', color: '#3b82f6',
              dialogue: ["The seas hold many mysteries!", "Brave the waves for great rewards!", "Chart new courses to fortune!"]
            },
            { id: 'east-mailbox', name: 'Gull-Post Delivery', type: 'mailbox', x: 1770, y: 715, sprite: 'üïäÔ∏è', color: '#6b7280',
              dialogue: ["Messages by sea and air!", "Fast delivery to any port!", "Trust the gulls with your mail!"]
            },

            // === WESTERN TOWN (Ironhold) NPCs ===
            { id: 'west-forgemaster', name: 'Forgemaster Thorek', type: 'blacksmith', x: 210, y: 660, sprite: 'üè≠', color: '#dc2626',
              dialogue: ["The great foundry never sleeps!", "Industrial-grade weapons and armor!", "Mass production, maximum quality!"],
              shop: [
                { id: 'factory-sword', name: 'Factory-Forged Blade', type: 'weapon', price: 150, description: 'Reliable and mass-produced', icon: 'üè≠‚öîÔ∏è' },
                { id: 'industrial-armor', name: 'Industrial Plate', type: 'armor', price: 220, description: 'Heavy-duty protection', icon: 'üè≠üõ°Ô∏è' }
              ]
            },
            { id: 'west-armorer', name: 'Arsenal-Keep Magnus', type: 'shopkeeper', x: 237, y: 656, sprite: 'üõ°Ô∏è', color: '#374151',
              dialogue: ["Military-grade equipment only!", "Arm yourself for serious combat!", "No compromise on protection!"],
              shop: [
                { id: 'tactical-gear', name: 'Tactical Harness', type: 'armor', price: 180, description: 'Combat-tested protection', icon: 'üéñÔ∏èüõ°Ô∏è' },
                { id: 'combat-blade', name: 'Combat Knife', type: 'weapon', price: 120, description: 'Military precision cutting', icon: 'üéñÔ∏è‚öîÔ∏è' }
              ]
            },
            { id: 'west-banker', name: 'Vault-Guard Durin', type: 'banker', x: 185, y: 674, sprite: 'üè¶', color: '#6b7280',
              dialogue: ["Dwarven vaults are unbreakable!", "Your gold is safer than in the mountains!", "Trust dwarven engineering!"]
            },
            { id: 'west-quest-giver', name: 'Engineer Clockwork', type: 'quest-giver', x: 220, y: 670, sprite: '‚öôÔ∏è', color: '#f59e0b',
              dialogue: ["The machines need maintenance!", "Help keep the foundry running!", "Gears and glory await!"]
            },

            // === SCATTERED OUTPOST NPCs ===
            // Northwest Outpost
            { id: 'frontier-trader', name: 'Frontier Joe', type: 'shopkeeper', x: 304, y: 302, sprite: 'ü§†', color: '#92400e',
              dialogue: ["Welcome to the frontier!", "Basic supplies for brave souls!", "Ain't much, but it's honest work!"],
              shop: [
                { id: 'frontier-supplies', name: 'Basic Supplies', type: 'misc', price: 10, description: 'Essential survival gear', icon: 'üéí' },
                { id: 'trail-rations', name: 'Trail Rations', type: 'food', price: 5, description: 'Keeps you fed on long journeys', icon: 'ü•©' }
              ]
            },
            { id: 'frontier-repair', name: 'Fix-It Fred', type: 'repair', x: 308, y: 298, sprite: 'üîß', color: '#6b7280',
              dialogue: ["Broke something out here?", "I can patch up most anything!", "Frontier repairs, frontier prices!"]
            },

            // Northeast Outpost  
            { id: 'wayfarer-host', name: 'Innkeeper Martha', type: 'innkeeper', x: 1605, y: 404, sprite: 'üè®', color: '#ec4899',
              dialogue: ["Rest your weary bones!", "Safe haven for travelers!", "Hot meals and warm beds!"]
            },
            { id: 'wayfarer-stable', name: 'Stable-Boy Tim', type: 'stable', x: 1610, y: 408, sprite: 'üêé', color: '#92400e',
              dialogue: ["Your mounts need rest too!", "Fresh hay and clean water!", "Best care for your companions!"]
            },

            // Southwest Outpost
            { id: 'wild-tamer', name: 'Beast-Master Koda', type: 'stable', x: 506, y: 1205, sprite: 'ü¶å', color: '#059669',
              dialogue: ["Wild mounts, wild adventures!", "Tame the untameable!", "Freedom rides on four legs!"]
            },
            { id: 'wild-quest', name: 'Ranger Silva', type: 'quest-giver', x: 502, y: 1208, sprite: 'üèπ', color: '#059669',
              dialogue: ["The wild lands need protection!", "Hunt the dangerous beasts!", "Nature's balance must be preserved!"]
            },

            // Northeast Tower
            { id: 'arcane-scholar', name: 'Archmage Mystral', type: 'trainer', x: 1404, y: 206, sprite: 'üßô‚Äç‚ôÇÔ∏è', color: '#7c3aed',
              dialogue: ["Knowledge is the ultimate power!", "Learn the arcane arts!", "Magic has no limits for the dedicated!"]
            },
            { id: 'tower-vendor', name: 'Reagent-Keeper Flux', type: 'shopkeeper', x: 1408, y: 206, sprite: '‚öóÔ∏è', color: '#8b5cf6',
              dialogue: ["Magical components for sale!", "Quality reagents, guaranteed potency!", "Fuel your magical research!"],
              shop: [
                { id: 'mana-crystal', name: 'Mana Crystal', type: 'reagent', price: 50, description: 'Pure magical energy', icon: 'üíé' },
                { id: 'spell-scroll', name: 'Spell Scroll', type: 'scroll', price: 75, description: 'Contains a powerful spell', icon: 'üìú‚ú®' }
              ]
            },

            // Southwest Crypt
            { id: 'crypt-keeper', name: 'Grave-Warden Morrigan', type: 'dungeon', x: 105, y: 1104, sprite: 'üíÄ', color: '#4b5563',
              dialogue: ["The dead do not rest easy...", "Brave the depths for ancient treasures!", "Only the worthy may pass!"]
            },
            { id: 'crypt-vendor', name: 'Bone-Trader Grimm', type: 'shopkeeper', x: 108, y: 1107, sprite: '‚ò†Ô∏è', color: '#1f2937',
              dialogue: ["Treasures from the departed!", "Death's bounty for the living!", "Dark wares for dark deeds!"],
              shop: [
                { id: 'bone-blade', name: 'Bone Reaper', type: 'weapon', price: 180, description: 'Sword carved from ancient bones', icon: '‚ò†Ô∏è‚öîÔ∏è' },
                { id: 'shadow-cloak', name: 'Cloak of Shadows', type: 'armor', price: 160, description: 'Hides you from the living', icon: 'üåëüëò' }
              ]
            },

            // === ADDITIONAL ROAMING NPCs ===
            // Crafting Stations (Anvils, Forges, etc.)
            { id: 'anvil-keeper1', name: 'Smith-Helper Bronson', type: 'crafting', x: 1200, y: 600, sprite: '‚öíÔ∏è', color: '#dc2626',
              dialogue: ["Use the anvil to craft!", "Bring materials, make wonders!", "Crafting is an art form!"]
            },
            { id: 'alchemy-station1', name: 'Brew-Master Sage', type: 'crafting', x: 800, y: 900, sprite: '‚öóÔ∏è', color: '#7c3aed',
              dialogue: ["Mix potions at my station!", "Combine ingredients for power!", "Alchemy transforms the mundane!"]
            },
            { id: 'cooking-station1', name: 'Chef Ramsden', type: 'crafting', x: 1500, y: 800, sprite: 'üç≥', color: '#f59e0b',
              dialogue: ["Cook your ingredients here!", "Hot meals give powerful buffs!", "Culinary magic is real magic!"]
            },

            // Multiple instances of same NPCs in different locations
            { id: 'mailbox-north', name: 'Northern Postal', type: 'mailbox', x: 1030, y: 160, sprite: 'üì¨', color: '#3b82f6',
              dialogue: ["Mail service to all corners!", "Send messages anywhere!", "The post always delivers!"]
            },
            { id: 'mailbox-south', name: 'Desert Postal', type: 'mailbox', x: 1125, y: 1375, sprite: 'üì¨', color: '#3b82f6',
              dialogue: ["Desert mail delivery!", "Even the sands can't stop us!", "Messages travel on desert winds!"]
            },
            { id: 'mailbox-west', name: 'Mountain Postal', type: 'mailbox', x: 195, y: 680, sprite: 'üì¨', color: '#3b82f6',
              dialogue: ["Mountain mail routes!", "High-altitude delivery service!", "Your mail reaches every peak!"]
            },

            // Additional Repair NPCs
            { id: 'repair-east', name: 'Saltwater Sam', type: 'repair', x: 1745, y: 720, sprite: 'üîß', color: '#6b7280',
              dialogue: ["Salt corrodes everything!", "But I can fix sea-damaged gear!", "Rust is my specialty!"]
            },

            // More Quest Givers
            { id: 'traveling-quest1', name: 'Wandering Scholar Thaddeus', type: 'quest-giver', x: 600, y: 500, sprite: 'üìö', color: '#6366f1',
              dialogue: ["Knowledge quests await!", "Discover ancient secrets!", "Learning leads to power!"]
            },
            { id: 'traveling-quest2', name: 'Merchant Caravan Leader', type: 'quest-giver', x: 1300, y: 1000, sprite: 'üöõ', color: '#92400e',
              dialogue: ["Escort our caravans!", "Trade routes need protection!", "Profitable partnerships await!"]
            },

            // More Faction Vendors
            { id: 'faction-north', name: 'Northern Alliance Rep', type: 'faction', x: 975, y: 170, sprite: 'üè¥', color: '#1e40af',
              dialogue: ["Serve the Northern Alliance!", "Cold steel, warm hearts!", "Loyalty to the frozen throne!"]
            },
            { id: 'faction-east', name: 'Maritime Guild Agent', type: 'faction', x: 1755, y: 725, sprite: 'üè¥', color: '#3b82f6',
              dialogue: ["Join the Maritime Guild!", "Rule the waves!", "The sea rewards the bold!"]
            }
        ];

        const SPAWN_POINTS = [
            { x: 1000, y: 750 },  // Center of massive world
            { x: 998, y: 750 },   // Spread around center
            { x: 1002, y: 750 },
            { x: 1000, y: 748 },
            { x: 1000, y: 752 }
        ];

        // Generate MASSIVE world map - the biggest MMORPG map ever created
        function createWorldMap() {
            const map = [];
            
            // Create massive terrain diversity
            for (let y = 0; y < WORLD_HEIGHT; y++) {
                const row = [];
                for (let x = 0; x < WORLD_WIDTH; x++) {
                    // Create diverse biomes and regions across the massive world
                    const centerX = WORLD_WIDTH / 2;
                    const centerY = WORLD_HEIGHT / 2;
                    const distanceFromCenter = Math.sqrt((x - centerX) * (x - centerX) + (y - centerY) * (y - centerY));
                    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
                    const normalizedDistance = distanceFromCenter / maxDistance;
                    
                    // Noise-based terrain generation for variety
                    const noise1 = Math.sin(x * 0.01) * Math.cos(y * 0.01);
                    const noise2 = Math.sin(x * 0.05) * Math.cos(y * 0.03);
                    const noise3 = Math.sin(x * 0.02) * Math.cos(y * 0.04);
                    const combinedNoise = (noise1 + noise2 * 0.5 + noise3 * 0.3) / 1.8;
                    
                    // World boundaries
                    if (y < 3 || y >= WORLD_HEIGHT - 3 || x < 3 || x >= WORLD_WIDTH - 3) {
                        row.push(TILES.water);  // Ocean boundaries
                    }
                    // Central starting town area (small compared to massive world)
                    else if (x >= centerX - 50 && x <= centerX + 50 && y >= centerY - 30 && y <= centerY + 30) {
                        if ((x >= centerX - 20 && x <= centerX - 10 && y >= centerY - 15 && y <= centerY - 5) ||
                            (x >= centerX + 10 && x <= centerX + 20 && y >= centerY - 15 && y <= centerY - 5)) {
                            // Town buildings
                            if (y === centerY - 15 || y === centerY - 5) row.push(TILES.wall);
                            else if (x === centerX - 20 || x === centerX - 10 || x === centerX + 10 || x === centerX + 20) row.push(TILES.wall);
                            else if ((x === centerX - 15 && y === centerY - 5) || (x === centerX + 15 && y === centerY - 5)) {
                                row.push(TILES.door);
                            } else row.push(TILES.floor);
                        }
                        // Town square
                        else if (x >= centerX - 5 && x <= centerX + 5 && y >= centerY - 5 && y <= centerY + 5) {
                            row.push(TILES.stone);
                        }
                        else {
                            row.push(TILES.grass);
                        }
                    }
                    // Diverse biomes based on position and noise
                    else if (normalizedDistance < 0.3) {
                        // Inner regions - grasslands and forests
                        if (combinedNoise > 0.2) row.push(TILES.stone);
                        else if (combinedNoise < -0.3) row.push(TILES.dirt);
                        else row.push(TILES.grass);
                    }
                    else if (normalizedDistance < 0.6) {
                        // Middle regions - mixed terrain
                        if (combinedNoise > 0.4) row.push(TILES.stone);
                        else if (combinedNoise > 0.1) row.push(TILES.dirt);
                        else if (combinedNoise < -0.2) row.push(TILES.water);
                        else row.push(TILES.grass);
                    }
                    else {
                        // Outer regions - wilderness and dangerous areas
                        if (combinedNoise > 0.3) row.push(TILES.stone);
                        else if (combinedNoise > -0.1) row.push(TILES.dirt);
                        else if (combinedNoise < -0.4) row.push(TILES.water);
                        else row.push(TILES.grass);
                    }
                }
                map.push(row);
            }
            return map;
        }

        const worldMap = createWorldMap();

        // Utility Functions
        function getClassStats(playerClass) {
            switch (playerClass) {
                case 'warrior': return { health: 120, mana: 30 };
                case 'mage': return { health: 80, mana: 100 };
                case 'archer': return { health: 100, mana: 50 };
                default: return { health: 100, mana: 50 };
            }
        }

        function getClassColor(playerClass) {
            switch (playerClass) {
                case 'warrior': return '#ef4444';
                case 'mage': return '#3b82f6';
                case 'archer': return '#10b981';
                default: return '#6b7280';
            }
        }

        function getClassIcon(playerClass) {
            switch (playerClass) {
                case 'warrior': return '‚öî';
                case 'mage': return '‚ú¶';
                case 'archer': return '‚ûµ';
                default: return '‚óè';
            }
        }

        function canMoveTo(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            
            if (tileX < 0 || tileX >= WORLD_WIDTH || tileY < 0 || tileY >= WORLD_HEIGHT) {
                return false;
            }
            
            return worldMap[tileY][tileX].walkable;
        }

        function lightenColor(color, amount) {
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                const newR = Math.min(255, r + amount * 255);
                const newG = Math.min(255, g + amount * 255);
                const newB = Math.min(255, b + amount * 255);
                return `rgb(${newR}, ${newG}, ${newB})`;
            }
            return color;
        }

        function darkenColor(color, amount) {
            if (color.startsWith('#')) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                const newR = Math.max(0, r - amount * 255);
                const newG = Math.max(0, g - amount * 255);
                const newB = Math.max(0, b - amount * 255);
                return `rgb(${newR}, ${newG}, ${newB})`;
            }
            return color;
        }

        // Game Functions
        async function initializePlayer(name, playerClass) {
            const spawnPoint = SPAWN_POINTS[Math.floor(Math.random() * SPAWN_POINTS.length)];
            const stats = getClassStats(playerClass);
            
            const newPlayer = {
                name,
                x: spawnPoint.x * TILE_SIZE,
                y: spawnPoint.y * TILE_SIZE,
                health: stats.health,
                maxHealth: stats.health,
                mana: stats.mana,
                maxMana: stats.mana,
                xp: 0,
                maxXp: 100,
                level: 1,
                class: playerClass,
                color: getClassColor(playerClass),
                isMoving: false,
                direction: 'down',
                gold: 100,
                inventory: []
            };

            try {
                const { data, error } = await supabase
                    .from('players')
                    .insert({
                        username: name,
                        x: newPlayer.x,
                        y: newPlayer.y,
                        health: newPlayer.health,
                        max_health: newPlayer.maxHealth,
                        mana: newPlayer.mana,
                        max_mana: newPlayer.maxMana,
                        level: newPlayer.level,
                        player_class: playerClass,
                        color: newPlayer.color,
                        direction: newPlayer.direction,
                        is_moving: false,
                        gold: newPlayer.gold,
                        zone_id: 'main-town'
                    })
                    .select()
                    .single();

                if (error) throw error;

                gameState.currentPlayer = {
                    id: data.id,
                    name: data.username,
                    x: data.x,
                    y: data.y,
                    health: data.health,
                    maxHealth: data.max_health,
                    mana: data.mana,
                    maxMana: data.max_mana,
                    level: data.level,
                    class: data.player_class,
                    color: data.color,
                    isMoving: data.is_moving,
                    direction: data.direction,
                    gold: data.gold,
                    inventory: []
                };

                gameState.isConnected = true;
                showGameUI();
                updatePlayerStats();
                setupRealtimeSubscriptions();
                loadInitialData();
                startGameLoop();
            } catch (error) {
                console.error('Error creating player:', error);
                alert('Failed to create player. Please try again.');
            }
        }

        function showGameUI() {
            document.getElementById('characterSelect').classList.add('hidden');
            document.getElementById('playerStats').classList.remove('hidden');
            document.getElementById('minimapPanel').classList.remove('hidden');
            document.getElementById('chatPanel').classList.remove('hidden');
            document.getElementById('controlsPanel').classList.remove('hidden');
        }

        function updatePlayerStats() {
            if (!gameState.currentPlayer) return;
            
            const player = gameState.currentPlayer;
            document.getElementById('playerNameDisplay').textContent = player.name;
            document.getElementById('playerClassDisplay').textContent = `Level ${player.level} ${player.class}`;
            document.getElementById('healthDisplay').textContent = `${player.health}/${player.maxHealth}`;
            document.getElementById('manaDisplay').textContent = `${player.mana}/${player.maxMana}`;
            document.getElementById('goldDisplay').textContent = player.gold;
            
            const healthPercent = (player.health / player.maxHealth) * 100;
            const manaPercent = (player.mana / player.maxMana) * 100;
            
            document.getElementById('healthBar').style.width = `${healthPercent}%`;
            document.getElementById('manaBar').style.width = `${manaPercent}%`;
        }

        function updateMinimap() {
            const minimap = document.getElementById('minimap');
            const playerCount = document.getElementById('playerCount');
            
            minimap.innerHTML = '';
            playerCount.textContent = Object.keys(gameState.players).length;
            
            const minimapRadius = 60; // Half of 120px
            const worldScale = minimapRadius / Math.max(WORLD_WIDTH, WORLD_HEIGHT);
            
            // Draw terrain features
            // Sample some buildings and terrain for the minimap
            BUILDINGS.forEach(building => {
                if (Math.random() < 0.3) { // Show only some buildings to avoid clutter
                    const terrainDot = document.createElement('div');
                    terrainDot.className = 'minimap-terrain';
                    terrainDot.style.backgroundColor = getBuildingColor(building.type);
                    terrainDot.style.width = '2px';
                    terrainDot.style.height = '2px';
                    terrainDot.style.opacity = '0.6';
                    
                    const x = building.x * worldScale;
                    const y = building.y * worldScale;
                    terrainDot.style.left = `${minimapRadius + x}px`;
                    terrainDot.style.top = `${minimapRadius + y}px`;
                    terrainDot.style.position = 'absolute';
                    
                    minimap.appendChild(terrainDot);
                }
            });
            
            // Add some terrain variety
            for (let i = 0; i < 50; i++) {
                const terrainDot = document.createElement('div');
                terrainDot.className = 'minimap-terrain';
                terrainDot.style.backgroundColor = Math.random() < 0.5 ? '#10b981' : '#64748b';
                terrainDot.style.width = '1px';
                terrainDot.style.height = '1px';
                terrainDot.style.opacity = '0.3';
                
                const x = (Math.random() * WORLD_WIDTH) * worldScale;
                const y = (Math.random() * WORLD_HEIGHT) * worldScale;
                terrainDot.style.left = `${minimapRadius + x}px`;
                terrainDot.style.top = `${minimapRadius + y}px`;
                terrainDot.style.position = 'absolute';
                
                minimap.appendChild(terrainDot);
            }
            
            // Current player first
            if (gameState.currentPlayer) {
                const playerDot = document.createElement('div');
                playerDot.className = 'minimap-player';
                playerDot.style.backgroundColor = gameState.currentPlayer.color;
                playerDot.style.border = '1px solid #10b981';
                playerDot.style.width = '5px';
                playerDot.style.height = '5px';
                
                const x = (gameState.currentPlayer.x / TILE_SIZE) * worldScale;
                const y = (gameState.currentPlayer.y / TILE_SIZE) * worldScale;
                playerDot.style.left = `${minimapRadius + x}px`;
                playerDot.style.top = `${minimapRadius + y}px`;
                
                minimap.appendChild(playerDot);
            }
            
            // Other players
            Object.values(gameState.players).forEach(player => {
                if (player.id !== gameState.currentPlayer?.id) {
                    const playerDot = document.createElement('div');
                    playerDot.className = 'minimap-player';
                    playerDot.style.backgroundColor = player.color;
                    
                    const x = (player.x / TILE_SIZE) * worldScale;
                    const y = (player.y / TILE_SIZE) * worldScale;
                    playerDot.style.left = `${minimapRadius + x}px`;
                    playerDot.style.top = `${minimapRadius + y}px`;
                    
                    minimap.appendChild(playerDot);
                }
            });
        }

        function addChatMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <span class="username">${message.username}:</span> ${message.message}
            `;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // Keep only last 20 messages
            while (chatMessages.children.length > 20) {
                chatMessages.removeChild(chatMessages.firstChild);
            }
        }

        async function sendMessage(message) {
            if (!gameState.currentPlayer || !message.trim()) return;

            try {
                await supabase
                    .from('chat_messages')
                    .insert({
                        player_id: gameState.currentPlayer.id,
                        username: gameState.currentPlayer.name,
                        message: message.trim(),
                        zone_id: 'main-town'
                    });
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        async function updatePlayerPosition(player) {
            if (!player.id) return;

            try {
                await supabase
                    .from('players')
                    .update({
                        x: player.x,
                        y: player.y,
                        direction: player.direction,
                        is_moving: player.isMoving,
                        last_seen: new Date().toISOString()
                    })
                    .eq('id', player.id);
            } catch (error) {
                console.error('Error updating player position:', error);
            }
        }

        function checkInteractions(playerX, playerY) {
            const playerTileX = Math.round(playerX / TILE_SIZE);
            const playerTileY = Math.round(playerY / TILE_SIZE);
            
            for (const npc of NPCS) {
                const distance = Math.abs(npc.x - playerTileX) + Math.abs(npc.y - playerTileY);
                if (distance <= 1) {
                    return { type: 'npc', target: npc };
                }
            }
            
            return null;
        }

        function showInteractionDialog(npc) {
            gameState.interactionTarget = npc;
            
            document.getElementById('npcName').textContent = npc.name;
            document.getElementById('npcDialogue').textContent = npc.dialogue[0];
            
            const shopItems = document.getElementById('shopItems');
            shopItems.innerHTML = '';
            
            if (npc.shop && npc.shop.length > 0) {
                shopItems.classList.remove('hidden');
                npc.shop.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item';
                    itemDiv.innerHTML = `
                        <div>
                            <strong>${item.icon} ${item.name}</strong>
                            <div style="font-size: 11px; color: hsl(120, 20%, 65%);">${item.description}</div>
                        </div>
                        <div>
                            <div style="color: hsl(60, 100%, 50%); font-weight: bold;">${item.price} Gold</div>
                            <button onclick="purchaseItem('${item.id}')" style="margin-top: 4px; padding: 4px 8px; font-size: 11px;">Buy</button>
                        </div>
                    `;
                    shopItems.appendChild(itemDiv);
                });
            } else {
                shopItems.classList.add('hidden');
            }
            
            document.getElementById('interactionOverlay').classList.remove('hidden');
            document.getElementById('interactionDialog').classList.remove('hidden');
        }

        function closeInteractionDialog() {
            document.getElementById('interactionOverlay').classList.add('hidden');
            document.getElementById('interactionDialog').classList.add('hidden');
            gameState.interactionTarget = null;
        }

        async function purchaseItem(itemId) {
            if (!gameState.interactionTarget || !gameState.currentPlayer) return;
            
            const item = gameState.interactionTarget.shop?.find(i => i.id === itemId);
            if (!item) return;
            
            if (gameState.currentPlayer.gold >= item.price) {
                // Update gold locally
                gameState.currentPlayer.gold -= item.price;
                updatePlayerStats();
                
                // Send chat message about purchase
                await sendMessage(`Purchased ${item.name} for ${item.price} gold!`);
                
                // Update player in database
                try {
                    await supabase
                        .from('players')
                        .update({ gold: gameState.currentPlayer.gold })
                        .eq('id', gameState.currentPlayer.id);
                } catch (error) {
                    console.error('Error updating gold:', error);
                }
                
                closeInteractionDialog();
            } else {
                alert('Not enough gold!');
            }
        }

        async function loadInitialData() {
            // Load players
            const { data: playersData } = await supabase
                .from('players')
                .select('*')
                .eq('zone_id', 'main-town');

            if (playersData) {
                playersData.forEach(dbPlayer => {
                    gameState.players[dbPlayer.id] = {
                        id: dbPlayer.id,
                        name: dbPlayer.username,
                        x: dbPlayer.x,
                        y: dbPlayer.y,
                        health: dbPlayer.health,
                        maxHealth: dbPlayer.max_health,
                        mana: dbPlayer.mana,
                        maxMana: dbPlayer.max_mana,
                        level: dbPlayer.level,
                        class: dbPlayer.player_class,
                        color: dbPlayer.color,
                        isMoving: dbPlayer.is_moving,
                        direction: dbPlayer.direction,
                        gold: dbPlayer.gold,
                        inventory: []
                    };
                });
                updateMinimap();
            }

            // Load recent messages
            const { data: messagesData } = await supabase
                .from('chat_messages')
                .select('*')
                .eq('zone_id', 'main-town')
                .order('created_at', { ascending: false })
                .limit(20);

            if (messagesData) {
                messagesData.reverse().forEach(msg => {
                    addChatMessage({
                        id: msg.id,
                        username: msg.username,
                        message: msg.message,
                        created_at: msg.created_at,
                        zone_id: msg.zone_id
                    });
                });
            }
        }

        function setupRealtimeSubscriptions() {
            // Subscribe to player updates
            supabase
                .channel('players')
                .on(
                    'postgres_changes',
                    {
                        event: '*',
                        schema: 'public',
                        table: 'players',
                        filter: 'zone_id=eq.main-town'
                    },
                    (payload) => {
                        if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
                            const dbPlayer = payload.new;
                            gameState.players[dbPlayer.id] = {
                                id: dbPlayer.id,
                                name: dbPlayer.username,
                                x: dbPlayer.x,
                                y: dbPlayer.y,
                                health: dbPlayer.health,
                                maxHealth: dbPlayer.max_health,
                                mana: dbPlayer.mana,
                                maxMana: dbPlayer.max_mana,
                                level: dbPlayer.level,
                                class: dbPlayer.player_class,
                                color: dbPlayer.color,
                                isMoving: dbPlayer.is_moving,
                                direction: dbPlayer.direction,
                                gold: dbPlayer.gold,
                                inventory: []
                            };
                            updateMinimap();
                        } else if (payload.eventType === 'DELETE') {
                            delete gameState.players[payload.old.id];
                            updateMinimap();
                        }
                    }
                )
                .subscribe();

            // Subscribe to chat messages
            supabase
                .channel('chat_messages')
                .on(
                    'postgres_changes',
                    {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'chat_messages',
                        filter: 'zone_id=eq.main-town'
                    },
                    (payload) => {
                        addChatMessage({
                            id: payload.new.id,
                            username: payload.new.username,
                            message: payload.new.message,
                            created_at: payload.new.created_at,
                            zone_id: payload.new.zone_id
                        });
                    }
                )
                .subscribe();
        }

        // Game Loop
        let updateTimeout;
        let animationFrame;

        function startGameLoop() {
            const gameLoop = () => {
                const now = Date.now();
                const deltaTime = (now - gameState.lastUpdate) / 1000;
                gameState.lastUpdate = now;

                if (gameState.currentPlayer) {
                    let newX = gameState.currentPlayer.x;
                    let newY = gameState.currentPlayer.y;
                    let isMoving = false;
                    let direction = gameState.currentPlayer.direction;

                    const moveDistance = MOVE_SPEED * deltaTime;
                    
                    if (gameState.keys.w || gameState.keys.arrowup) {
                        const testY = Math.max(TILE_SIZE, newY - moveDistance);
                        if (canMoveTo(newX, testY)) {
                            newY = testY;
                            isMoving = true;
                            direction = 'up';
                        }
                    }
                    if (gameState.keys.s || gameState.keys.arrowdown) {
                        const testY = Math.min((WORLD_HEIGHT - 1) * TILE_SIZE, newY + moveDistance);
                        if (canMoveTo(newX, testY)) {
                            newY = testY;
                            isMoving = true;
                            direction = 'down';
                        }
                    }
                    if (gameState.keys.a || gameState.keys.arrowleft) {
                        const testX = Math.max(TILE_SIZE, newX - moveDistance);
                        if (canMoveTo(testX, newY)) {
                            newX = testX;
                            isMoving = true;
                            direction = 'left';
                        }
                    }
                    if (gameState.keys.d || gameState.keys.arrowright) {
                        const testX = Math.min((WORLD_WIDTH - 1) * TILE_SIZE, newX + moveDistance);
                        if (canMoveTo(testX, newY)) {
                            newX = testX;
                            isMoving = true;
                            direction = 'right';
                        }
                    }

                    // Update player if position changed
                    if (newX !== gameState.currentPlayer.x || newY !== gameState.currentPlayer.y || isMoving !== gameState.currentPlayer.isMoving) {
                        gameState.currentPlayer.x = newX;
                        gameState.currentPlayer.y = newY;
                        gameState.currentPlayer.isMoving = isMoving;
                        gameState.currentPlayer.direction = direction;
                        
                        // Throttle database updates
                        if (updateTimeout) {
                            clearTimeout(updateTimeout);
                        }
                        updateTimeout = setTimeout(() => {
                            updatePlayerPosition(gameState.currentPlayer);
                        }, UPDATE_INTERVAL);
                    }
                }

                // Render the game
                render();
                
                gameState.animationFrame += 0.1;
                animationFrame = requestAnimationFrame(gameLoop);
            };

            animationFrame = requestAnimationFrame(gameLoop);
        }

        // Rendering
        function render() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'hsl(220, 13%, 8%)');
            gradient.addColorStop(1, 'hsl(220, 13%, 12%)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate camera offset - PERFECT CENTERING
            let cameraX = 0;
            let cameraY = 0;
            
            if (gameState.currentPlayer) {
                // Center the player EXACTLY in the middle of the screen
                cameraX = canvas.width / 2 - gameState.currentPlayer.x - TILE_SIZE / 2;
                cameraY = canvas.height / 2 - gameState.currentPlayer.y - TILE_SIZE / 2;
                
                // For massive open world, allow free camera movement in all directions
                // Only clamp when near world boundaries to prevent seeing beyond the map
                const worldWidthPixels = WORLD_WIDTH * TILE_SIZE;
                const worldHeightPixels = WORLD_HEIGHT * TILE_SIZE;
                
                const minCameraX = canvas.width - worldWidthPixels;
                const minCameraY = canvas.height - worldHeightPixels;
                
                // Only clamp if we're near the edges of the massive world
                if (worldWidthPixels > canvas.width) {
                    cameraX = Math.min(0, Math.max(minCameraX, cameraX));
                }
                if (worldHeightPixels > canvas.height) {
                    cameraY = Math.min(0, Math.max(minCameraY, cameraY));
                }
            }

            ctx.save();
            ctx.translate(cameraX, cameraY);

            // Draw tiles
            drawTiles(ctx);
            
            // Draw buildings
            BUILDINGS.forEach(building => drawBuilding(ctx, building));
            
            // Draw NPCs
            NPCS.forEach(npc => drawNPC(ctx, npc));
            
            // Draw players
            Object.values(gameState.players).forEach(player => {
                const isCurrentPlayer = gameState.currentPlayer && player.id === gameState.currentPlayer.id;
                drawPlayer(ctx, player, isCurrentPlayer);
            });

            ctx.restore();
        }

        function drawTiles(ctx) {
            // OPTIMIZED RENDERING for massive world - only draw visible tiles
            const canvas = document.getElementById('gameCanvas');
            
            // Calculate current camera transform
            const transform = ctx.getTransform();
            const viewX = -transform.e;
            const viewY = -transform.f;
            const viewWidth = canvas.width;
            const viewHeight = canvas.height;
            
            // Calculate visible tile bounds with some padding
            const startX = Math.max(0, Math.floor(viewX / TILE_SIZE) - 2);
            const endX = Math.min(WORLD_WIDTH, Math.ceil((viewX + viewWidth) / TILE_SIZE) + 2);
            const startY = Math.max(0, Math.floor(viewY / TILE_SIZE) - 2);
            const endY = Math.min(WORLD_HEIGHT, Math.ceil((viewY + viewHeight) / TILE_SIZE) + 2);
            
            // Only render visible tiles for performance in massive world
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const tile = worldMap[y][x];
                    const tileX = x * TILE_SIZE;
                    const tileY = y * TILE_SIZE;

                    // Create gradient for tiles
                    const gradient = ctx.createRadialGradient(
                        tileX + TILE_SIZE/2, tileY + TILE_SIZE/2, 0,
                        tileX + TILE_SIZE/2, tileY + TILE_SIZE/2, TILE_SIZE/2
                    );

                    if (tile.type === 'water') {
                        const wave = Math.sin(gameState.animationFrame + x * 0.5 + y * 0.3) * 0.2;
                        gradient.addColorStop(0, `hsl(200, 100%, ${50 + wave * 10}%)`);
                        gradient.addColorStop(1, `hsl(200, 100%, ${40 + wave * 5}%)`);
                    } else {
                        gradient.addColorStop(0, tile.color);
                        gradient.addColorStop(1, darkenColor(tile.color, 0.2));
                    }

                    ctx.fillStyle = gradient;
                    ctx.fillRect(tileX, tileY, TILE_SIZE, TILE_SIZE);

                    // Add texture for grass
                    if (tile.type === 'grass') {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        for (let i = 0; i < 2; i++) {
                            const px = tileX + Math.random() * TILE_SIZE;
                            const py = tileY + Math.random() * TILE_SIZE;
                            ctx.fillRect(px, py, 1, 1);
                        }
                    }

                    // Tile borders
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(tileX, tileY, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        function drawBuilding(ctx, building) {
            const x = building.x * TILE_SIZE;
            const y = building.y * TILE_SIZE;
            const w = building.width * TILE_SIZE;
            const h = building.height * TILE_SIZE;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(x + 4, y + 4, w, h);

            // Building gradient
            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
            const buildingColor = getBuildingColor(building.type);
            gradient.addColorStop(0, buildingColor);
            gradient.addColorStop(1, darkenColor(buildingColor, 0.3));
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, w, h);

            // Border with glow
            ctx.shadowColor = buildingColor;
            ctx.shadowBlur = 10;
            ctx.strokeStyle = lightenColor(buildingColor, 0.3);
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, w, h);
            ctx.shadowBlur = 0;

            // Icon
            ctx.save();
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.fillStyle = '#ffffff';
            ctx.font = `${Math.min(w, h) * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(building.icon, x + w / 2, y + h / 2 + 6);
            ctx.restore();

            // Name
            ctx.save();
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 3;
            ctx.fillStyle = '#10b981';
            ctx.font = '12px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(building.name, x + w / 2, y - 6);
            ctx.restore();
        }

        function drawNPC(ctx, npc) {
            const x = npc.x * TILE_SIZE + TILE_SIZE / 2;
            const y = npc.y * TILE_SIZE + TILE_SIZE / 2;
            const size = TILE_SIZE * 0.8;
            
            const float = Math.sin(gameState.animationFrame * 2 + npc.x * 0.5) * 2;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(x, y + size/2 + 4, size/2 * 0.8, size/4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body gradient
            const gradient = ctx.createRadialGradient(x, y + float, 0, x, y + float, size/2);
            gradient.addColorStop(0, lightenColor(npc.color, 0.2));
            gradient.addColorStop(1, npc.color);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y + float, size/2, 0, Math.PI * 2);
            ctx.fill();

            // Glow
            ctx.shadowColor = npc.color;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y + float, size/2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Sprite
            ctx.fillStyle = '#ffffff';
            ctx.font = `${size * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(npc.sprite, x, y + float + size * 0.2);

            // Name
            ctx.save();
            ctx.shadowColor = '#10b981';
            ctx.shadowBlur = 5;
            ctx.fillStyle = '#10b981';
            ctx.font = '10px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(npc.name, x, y + float - size/2 - 6);
            ctx.restore();

            // Interaction indicator
            const pulse = Math.sin(gameState.animationFrame * 4) * 0.5 + 0.5;
            ctx.fillStyle = getNPCTypeColor(npc.type);
            ctx.globalAlpha = 0.7 + pulse * 0.3;
            ctx.beginPath();
            ctx.arc(x + size/2 - 4, y + float - size/2 + 4, 4 + pulse * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function drawPlayer(ctx, player, isCurrentPlayer) {
            const size = TILE_SIZE * 0.85;
            const bob = player.isMoving ? Math.sin(gameState.animationFrame * 8) * 2 : 0;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.ellipse(player.x, player.y + size/2 + 6, size/2 * 0.8, size/4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Glow for current player
            if (isCurrentPlayer) {
                const pulse = Math.sin(gameState.animationFrame * 2) * 0.3 + 0.7;
                ctx.shadowColor = player.color;
                ctx.shadowBlur = 25 * pulse;
            }

            // Body gradient
            const gradient = ctx.createRadialGradient(
                player.x, player.y + bob, 0,
                player.x, player.y + bob, size/2
            );
            gradient.addColorStop(0, lightenColor(player.color, 0.3));
            gradient.addColorStop(1, player.color);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(player.x, player.y + bob, size/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Border
            ctx.strokeStyle = isCurrentPlayer ? '#10b981' : 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = isCurrentPlayer ? 3 : 2;
            ctx.beginPath();
            ctx.arc(player.x, player.y + bob, size/2, 0, Math.PI * 2);
            ctx.stroke();

            // Class icon
            ctx.fillStyle = '#ffffff';
            ctx.font = `${size * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(getClassIcon(player.class), player.x, player.y + bob + size * 0.2);

            // Name
            ctx.save();
            ctx.shadowColor = isCurrentPlayer ? '#10b981' : 'rgba(255, 255, 255, 0.5)';
            ctx.shadowBlur = 5;
            ctx.fillStyle = isCurrentPlayer ? '#10b981' : '#ffffff';
            ctx.font = '10px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(player.name, player.x, player.y + bob - size/2 - 6);
            ctx.restore();

            // Health bar for current player
            if (isCurrentPlayer) {
                const barWidth = size;
                const barHeight = 4;
                const barY = player.y + bob + size/2 + 10;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(player.x - barWidth/2, barY, barWidth, barHeight);
                
                const healthPercent = player.health / player.maxHealth;
                const healthColor = healthPercent > 0.5 ? '#10b981' : 
                                   healthPercent > 0.25 ? '#fbbf24' : '#ef4444';
                ctx.fillStyle = healthColor;
                ctx.fillRect(player.x - barWidth/2, barY, barWidth * healthPercent, barHeight);
            }
        }

        function getBuildingColor(type) {
            switch (type) {
                case 'shop': return '#dc2626';
                case 'market': return '#059669';
                case 'salon': return '#ec4899';
                case 'arena': return '#f59e0b';
                case 'tavern': return '#92400e';
                case 'guild': return '#7c3aed';
                case 'bank': return '#1f2937';
                default: return '#6b7280';
            }
        }

        function getNPCTypeColor(type) {
            switch (type) {
                case 'shopkeeper': return '#fbbf24';
                case 'vendor': return '#10b981';
                case 'trainer': return '#f59e0b';
                case 'questgiver': return '#3b82f6';
                case 'guard': return '#ef4444';
                default: return '#6b7280';
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Character selection
            let selectedClass = 'warrior';
            
            document.querySelectorAll('.class-button').forEach(button => {
                button.addEventListener('click', function() {
                    document.querySelectorAll('.class-button').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedClass = this.dataset.class;
                });
            });
            
            // Default selection
            document.querySelector('.class-button[data-class="warrior"]').classList.add('selected');

            document.getElementById('startGame').addEventListener('click', function() {
                const playerName = document.getElementById('playerName').value.trim();
                if (playerName) {
                    initializePlayer(playerName, selectedClass);
                } else {
                    alert('Please enter your name!');
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', function(e) {
                const key = e.key.toLowerCase();
                if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
                    e.preventDefault();
                    gameState.keys[key] = true;
                } else if (key === 'e' || key === ' ') {
                    if (document.activeElement?.tagName !== 'INPUT') {
                        e.preventDefault();
                        handleInteraction();
                    }
                } else if (key === 'enter') {
                    if (document.activeElement === document.getElementById('chatInput')) {
                        e.preventDefault();
                        handleSendMessage();
                    }
                }
            });

            document.addEventListener('keyup', function(e) {
                const key = e.key.toLowerCase();
                gameState.keys[key] = false;
            });

            // Chat functionality
            document.getElementById('sendButton').addEventListener('click', handleSendMessage);
            document.getElementById('chatExpandBtn').addEventListener('click', toggleChatExpansion);
            document.getElementById('closeControlsBtn').addEventListener('click', closeControlsPanel);
            
            function handleSendMessage() {
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                if (message) {
                    sendMessage(message);
                    chatInput.value = '';
                }
            }

            function toggleChatExpansion() {
                const chatPanel = document.getElementById('chatPanel');
                const expandBtn = document.getElementById('chatExpandBtn');
                
                chatPanel.classList.toggle('expanded');
                expandBtn.textContent = chatPanel.classList.contains('expanded') ? '‚á≤' : '‚á±';
            }

            function closeControlsPanel() {
                document.getElementById('controlsPanel').classList.add('hidden');
            }

            function handleInteraction() {
                if (!gameState.currentPlayer) return;
                
                const interaction = checkInteractions(gameState.currentPlayer.x, gameState.currentPlayer.y);
                if (interaction?.type === 'npc') {
                    showInteractionDialog(interaction.target);
                }
            }

            // Interaction dialog
            document.getElementById('closeDialog').addEventListener('click', closeInteractionDialog);
            document.getElementById('interactionOverlay').addEventListener('click', closeInteractionDialog);

            // Global purchase function
            window.purchaseItem = purchaseItem;

            // Cleanup on page unload
            window.addEventListener('beforeunload', async function() {
                if (gameState.currentPlayer?.id) {
                    try {
                        await supabase
                            .from('players')
                            .delete()
                            .eq('id', gameState.currentPlayer.id);
                    } catch (error) {
                        console.error('Error cleaning up player:', error);
                    }
                }
            });
        });
    </script>
</body>
</html>
